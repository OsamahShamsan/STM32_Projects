
// -----------------------------
// File: uart_writer.c
// -----------------------------
#include "uart_writer.h"
#include <stddef.h>

static char message_queue[UART_QUEUE_DEPTH][UART_MSG_MAX_LEN];
static volatile uint8_t queue_head = 0;
static volatile uint8_t queue_tail = 0;
static volatile uint8_t queue_count = 0;

static uint8_t tx_buffer[UART_TX_BUFFER_SIZE];
static const char* current_str = NULL;
static size_t str_len = 0;
static size_t str_sent = 0;
static volatile bool uart_tx_busy = false;

static void uart_start_next_message(void);


bool uart_send_blocking(const char* str) {
    if (!str) return false;

    size_t total_len = strlen(str);
    size_t sent = 0;

    while (sent < total_len) {
        size_t remaining = total_len - sent;
        uint16_t chunk_len = (remaining > UART_TX_BUFFER_SIZE) ? UART_TX_BUFFER_SIZE : (uint16_t)remaining;

        if (HAL_UART_Transmit(&huart2, (uint8_t*)&str[sent], chunk_len, UART_TX_TIMEOUT_MS) != HAL_OK)
            return false;

        sent += chunk_len;
    }
    return true;
}

bool uart_send_async(const char* str) {
    if (!str) return false;

    size_t len = strlen(str);
    if (len >= UART_MSG_MAX_LEN || queue_count >= UART_QUEUE_DEPTH)
        return false;  // message too long or queue full

    // Copy message into queue
    __disable_irq();  // critical section
    strncpy(message_queue[queue_tail], str, UART_MSG_MAX_LEN - 1);
    message_queue[queue_tail][UART_MSG_MAX_LEN - 1] = '\0';  // ensure null-termination
    queue_tail = (uint8_t)(queue_tail + 1) % UART_QUEUE_DEPTH;
    queue_count++;
    __enable_irq();

    if (!uart_tx_busy) {
        uart_start_next_message();
    }

    return true;
}

static void uart_start_next_message(void) {
    if (queue_count == 0 || uart_tx_busy) return;

    current_str = message_queue[queue_head];
    str_len = strlen(current_str);
    str_sent = 0;
    uart_tx_busy = true;

    // Advance queue
    queue_head = (uint8_t)(queue_head + 1) % UART_QUEUE_DEPTH;
    queue_count--;

    // Send first chunk
    size_t chunk_len = (str_len > UART_TX_BUFFER_SIZE) ? UART_TX_BUFFER_SIZE : str_len;
    memcpy(tx_buffer, current_str, chunk_len);
    str_sent += chunk_len;
    HAL_UART_Transmit_IT(&huart2, tx_buffer, (uint16_t)chunk_len);
}

void HAL_UART_TxCpltCallback(UART_HandleTypeDef* huart) {
    if (huart != &huart2 || !uart_tx_busy)
        return;

    if (str_sent < str_len) {
        size_t remaining = str_len - str_sent;
        size_t chunk_len = (remaining > UART_TX_BUFFER_SIZE) ? UART_TX_BUFFER_SIZE : remaining;
        memcpy(tx_buffer, &current_str[str_sent], chunk_len);
        str_sent += chunk_len;
        HAL_UART_Transmit_IT(&huart2, tx_buffer, (uint16_t)chunk_len);
    } else {
        uart_tx_busy = false;
        current_str = NULL;
        str_len = 0;
        str_sent = 0;

        uart_start_next_message();  // trigger next message if queued
    }
}

bool uart_is_busy(void) {
    return uart_tx_busy;
}

