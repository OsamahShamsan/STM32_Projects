#include "uart_dma.h"
#include <string.h>

// --- Internal state ---
static UART_HandleTypeDef* uart_dma_handle = NULL;
static uint8_t dma_rx_buffer[UART_RX_BUFFER_SIZE];
static uint16_t last_read_pos = 0;

void uart_dma_init(UART_HandleTypeDef* huart) {
    if (huart == NULL) {
        // Optionally add assert or error handling
        return;
    }

    uart_dma_handle = huart;
    HAL_UART_Receive_DMA(uart_dma_handle, dma_rx_buffer, UART_RX_BUFFER_SIZE);
    __HAL_UART_ENABLE_IT(uart_dma_handle, UART_IT_IDLE);
}

void uart_dma_handle_idle(UART_HandleTypeDef* huart) {
    if (huart != uart_dma_handle) return;  // Safety check: only process for known UART

    __HAL_UART_CLEAR_IDLEFLAG(huart);
    // Optionally: signal application layer with a flag (no direct call to menu or vt100)
}

const uint8_t* uart_dma_get_new_bytes(uint16_t* count) {
    static uint8_t temp_buf[UART_RX_BUFFER_SIZE];
    if (uart_dma_handle == NULL) {
        *count = 0;
        return temp_buf;
    }

    uint16_t dma_pos = UART_RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(uart_dma_handle->hdmarx);
    uint16_t temp_count = 0;

    if (dma_pos != last_read_pos) {
        if (dma_pos > last_read_pos) {
            temp_count = dma_pos - last_read_pos;
            memcpy(temp_buf, &dma_rx_buffer[last_read_pos], temp_count);
        } else {
            temp_count = (UART_RX_BUFFER_SIZE - last_read_pos) + dma_pos;
            memcpy(temp_buf, &dma_rx_buffer[last_read_pos], UART_RX_BUFFER_SIZE - last_read_pos);
            memcpy(&temp_buf[UART_RX_BUFFER_SIZE - last_read_pos], dma_rx_buffer, dma_pos);
        }
        last_read_pos = dma_pos;
    }

    *count = temp_count;
    return temp_buf;
}
